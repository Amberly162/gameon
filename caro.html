<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>C·ªù Caro</title>
    <style>
      /* CSS - Thi·∫øt k·∫ø b·∫£ng c·ªù */
      body {
        font-family: Arial, sans-serif;
        text-align: center;
        background-color: #f0f0f0;
      }

      h1 {
        margin-top: 20px;
      }

      #game {
        margin: 20px auto;
        display: inline-block;
        text-align: center;
      }

      #board {
        display: grid;
        grid-template-columns: repeat(3, 100px);
        grid-template-rows: repeat(3, 100px);
        gap: 5px;
      }

      .cell {
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #fff;
        border: 1px solid #000;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        height: 100px;
        width: 100px;
      }

      .cell.taken {
        cursor: not-allowed;
      }

      #status {
        margin-top: 20px;
        font-size: 18px;
        font-weight: bold;
      }

      #reset,
      #mode-switch {
        margin-top: 10px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
      }

      #controls {
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <h1>C·ªù Caro</h1>
    <div id="controls">
      <button id="mode-switch">Ch·∫ø ƒë·ªô: 2 Ng∆∞·ªùi Ch∆°i</button>
      <button id="reset">Ch∆°i l·∫°i</button>
    </div>
    <div id="game">
      <div id="board"></div>
      <div id="status"></div>
    </div>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const boardElement = document.getElementById("board");
        const statusElement = document.getElementById("status");
        const resetButton = document.getElementById("reset");
        const modeSwitchButton = document.getElementById("mode-switch");

        const boardSize = 3;
        let board = Array(boardSize)
          .fill(null)
          .map(() => Array(boardSize).fill(""));
        let currentPlayer = "X";
        let gameActive = true;
        let singlePlayerMode = false; // M·∫∑c ƒë·ªãnh l√† 2 ng∆∞·ªùi ch∆°i

        // T·∫°o b·∫£ng c·ªù
        function createBoard() {
          boardElement.innerHTML = "";
          board.forEach((row, rowIndex) => {
            row.forEach((cell, colIndex) => {
              const cellElement = document.createElement("div");
              cellElement.classList.add("cell");
              cellElement.dataset.row = rowIndex;
              cellElement.dataset.col = colIndex;
              cellElement.addEventListener("click", handleCellClick);
              boardElement.appendChild(cellElement);
            });
          });
        }

        // Ki·ªÉm tra th·∫Øng
        function checkWinner() {
          // Ki·ªÉm tra h√†ng ngang, h√†ng d·ªçc
          for (let i = 0; i < boardSize; i++) {
            if (board[i].every((cell) => cell === currentPlayer)) return true; // H√†ng ngang
            if (board.every((row) => row[i] === currentPlayer)) return true; // H√†ng d·ªçc
          }
          // Ki·ªÉm tra ƒë∆∞·ªùng ch√©o
          if (board.every((row, idx) => row[idx] === currentPlayer))
            return true;
          if (
            board.every(
              (row, idx) => row[boardSize - 1 - idx] === currentPlayer
            )
          )
            return true;

          return false;
        }

        // Ki·ªÉm tra h√≤a
        function checkDraw() {
          return board.flat().every((cell) => cell !== "");
        }

        // X·ª≠ l√Ω khi ng∆∞·ªùi ch∆°i click v√†o √¥
        function handleCellClick(event) {
          if (!gameActive) return;

          const row = event.target.dataset.row;
          const col = event.target.dataset.col;

          // Ki·ªÉm tra √¥ ƒë√£ ƒë∆∞·ª£c ƒë√°nh hay ch∆∞a
          if (board[row][col] !== "") return;

          // ƒê√°nh d·∫•u l∆∞·ª£t ch∆°i
          board[row][col] = currentPlayer;
          event.target.textContent = currentPlayer;
          event.target.classList.add("taken");

          // Ki·ªÉm tra k·∫øt qu·∫£
          if (checkWinner()) {
            statusElement.textContent = `Ng∆∞·ªùi ch∆°i ${currentPlayer} th·∫Øng! üéâ`;
            gameActive = false;
          } else if (checkDraw()) {
            statusElement.textContent = "H√≤a! üòê";
            gameActive = false;
          } else {
            // Chuy·ªÉn l∆∞·ª£t ho·∫∑c ƒë·ªÉ m√°y ch∆°i
            currentPlayer = currentPlayer === "X" ? "O" : "X";
            statusElement.textContent = `ƒê·∫øn l∆∞·ª£t ng∆∞·ªùi ch∆°i ${currentPlayer}`;
            if (singlePlayerMode && currentPlayer === "O") {
              setTimeout(computerPlay, 500); // M√°y t·ª± ƒë·ªông ch∆°i sau 0.5 gi√¢y
            }
          }
        }

        // M√°y th·ª±c hi·ªán n∆∞·ªõc ƒëi
        function computerPlay() {
          if (!gameActive) return;

          // T√¨m n∆∞·ªõc ƒëi ƒë·ªÉ ch·∫∑n ng∆∞·ªùi ch∆°i ho·∫∑c t·ª± th·∫Øng
          let bestMove = findBestMove();
          if (!bestMove) {
            // N·∫øu kh√¥ng c√≥ n∆∞·ªõc ƒëi t·ªëi ∆∞u, ƒë√°nh ng·∫´u nhi√™n
            const emptyCells = [];
            board.forEach((row, rowIndex) => {
              row.forEach((cell, colIndex) => {
                if (cell === "")
                  emptyCells.push({ row: rowIndex, col: colIndex });
              });
            });
            bestMove =
              emptyCells[Math.floor(Math.random() * emptyCells.length)];
          }

          const { row, col } = bestMove;
          const cellElement = boardElement.querySelector(
            `[data-row='${row}'][data-col='${col}']`
          );
          board[row][col] = currentPlayer;
          cellElement.textContent = currentPlayer;
          cellElement.classList.add("taken");

          // Ki·ªÉm tra k·∫øt qu·∫£
          if (checkWinner()) {
            statusElement.textContent = `Ng∆∞·ªùi ch∆°i ${currentPlayer} th·∫Øng! üéâ`;
            gameActive = false;
          } else if (checkDraw()) {
            statusElement.textContent = "H√≤a! üòê";
            gameActive = false;
          } else {
            currentPlayer = currentPlayer === "X" ? "O" : "X";
            statusElement.textContent = `ƒê·∫øn l∆∞·ª£t ng∆∞·ªùi ch∆°i ${currentPlayer}`;
          }
        }

        // T√¨m n∆∞·ªõc ƒëi t·ªët nh·∫•t
        function findBestMove() {
          // Ki·ªÉm tra c√°c h√†ng, c·ªôt v√† ƒë∆∞·ªùng ch√©o
          for (let i = 0; i < boardSize; i++) {
            // Ki·ªÉm tra h√†ng
            if (canBlockOrWin(board[i])) {
              return { row: i, col: board[i].indexOf("") };
            }
            // Ki·ªÉm tra c·ªôt
            const col = board.map((row) => row[i]);
            if (canBlockOrWin(col)) {
              return { row: col.indexOf(""), col: i };
            }
          }
          // Ki·ªÉm tra ƒë∆∞·ªùng ch√©o ch√≠nh
          const mainDiagonal = board.map((row, idx) => row[idx]);
          if (canBlockOrWin(mainDiagonal)) {
            const index = mainDiagonal.indexOf("");
            return { row: index, col: index };
          }
          // Ki·ªÉm tra ƒë∆∞·ªùng ch√©o ph·ª•
          const antiDiagonal = board.map(
            (row, idx) => row[boardSize - 1 - idx]
          );
          if (canBlockOrWin(antiDiagonal)) {
            const index = antiDiagonal.indexOf("");
            return { row: index, col: boardSize - 1 - index };
          }

          return null; // Kh√¥ng c√≥ n∆∞·ªõc ƒëi ƒë·∫∑c bi·ªát
        }

        // Ki·ªÉm tra n·∫øu c√≥ th·ªÉ ch·∫∑n ho·∫∑c th·∫Øng
        function canBlockOrWin(line) {
          const countPlayer = line.filter((cell) => cell === "X").length;
          const countAI = line.filter((cell) => cell === "O").length;
          return (countPlayer === 2 || countAI === 2) && line.includes("");
        }

        // Chuy·ªÉn ƒë·ªïi ch·∫ø ƒë·ªô ch∆°i
        function toggleMode() {
          singlePlayerMode = !singlePlayerMode;
          modeSwitchButton.textContent = singlePlayerMode
            ? "Ch·∫ø ƒë·ªô: 1 Ng∆∞·ªùi Ch∆°i"
            : "Ch·∫ø ƒë·ªô: 2 Ng∆∞·ªùi Ch∆°i";
          resetGame();
        }

        // Kh·ªüi ƒë·ªông l·∫°i tr√≤ ch∆°i
        function resetGame() {
          board = Array(boardSize)
            .fill(null)
            .map(() => Array(boardSize).fill(""));
          currentPlayer = "X";
          gameActive = true;
          statusElement.textContent = `ƒê·∫øn l∆∞·ª£t ng∆∞·ªùi ch∆°i ${currentPlayer}`;
          createBoard();
        }

        // G·∫Øn s·ª± ki·ªán
        resetButton.addEventListener("click", resetGame);
        modeSwitchButton.addEventListener("click", toggleMode);

        // Kh·ªüi t·∫°o b·∫£ng
        resetGame();
      });
    </script>
  </body>
</html>
